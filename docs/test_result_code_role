## 심리 검사 코드 생성 규칙 및 최적 구현 방법 요약

요청하신 내용을 정리하여 보기 쉽게 요약해 드립니다.

### I. 심리 검사 결과 코드 생성 규칙

1.  **코드 기본 구조 (예시: MP250-AA001)**
    *   `[접두사(2)] + [년도(2)] + [시퀀스번호(1)] + [알파벳코드(2)] + [숫자코드(3)] + [확장문자(선택적, 가변)]`
    *   하이픈(-)은 시각적 구분용이며, DB 저장 시에는 제외됩니다.

2.  **구성 요소 상세:**
    *   **검사 유형별 접두사 (2자리):**
        *   `MP`: 전문가용 MBTI
        *   `MA`: 개인용 MBTI
        *   `MG`: 그룹형 MBTI
        *   `EP`: 전문가용 이고-오케이
        *   `EA`: 개인용 이고-오케이
        *   `EG`: 그룹형 이고-오케이
        *   `AP`: 전문가용 애니어그램
        *   `AA`: 개인용 애니어그램
        *   `AG`: 그룹형 애니어그램
    *   **년도 코드 (2자리):** 현재 년도의 마지막 2자리 (예: 2025년 → `25`)
    *   **시퀀스 번호 (1자리):**
        *   `0` ~ `9` 범위, 연도별 초기화.
        *   `9` 초과 시 `0`으로 리셋되며, 확장 문자 추가/증가.
    *   **알파벳 코드 (2자리):**
        *   `AA` ~ `ZZ` 순차 증가 (AA → AB ... AZ → BA ... ZZ).
        *   `ZZ` 초과 시 `AA`로 리셋되며, 시퀀스 번호 증가.
    *   **숫자 코드 (3자리):**
        *   `000` ~ `999` 순차 증가 (앞자리 0 채움).
        *   `999` 초과 시 `000`으로 리셋되며, 알파벳 코드 증가.
    *   **확장 문자 (선택적, 가변 길이):**
        *   시퀀스 번호가 `9`를 초과하여 `0`으로 리셋될 때 추가되거나 증가.
        *   `A` → `B` ... → `Z` → `AA` → `AB` ... 순서로 증가.

3.  **코드 생성(증가) 순서:**
    1.  **숫자 코드** +1.
    2.  **숫자 코드 오버플로우 (999 → 000):** **알파벳 코드** +1.
    3.  **알파벳 코드 오버플로우 (ZZ → AA):** **시퀀스 번호** +1.
    4.  **시퀀스 번호 오버플로우 (9 → 0):** **확장 문자** 추가 또는 +1.

---

### II. 중복 없는 코드 생성 및 동시성 관리 방법 (1000명 동시 요청 대응)

**핵심 원칙: 중앙 집중식 카운터 관리와 데이터베이스 기능 활용**

1.  **중앙 카운터 DB 테이블 운영 (`CodeCounters` 등):**
    *   **목적:** 각 `(검사유형 접두사, 년도)` 조합별로 마지막으로 생성된 코드의 구성요소(시퀀스, 알파벳, 숫자, 확장자)를 추적 및 관리합니다.
    *   **주요 컬럼:** `prefix`, `year_code_val`, `last_sequence_no`, `last_alpha_code`, `last_numeric_code`, `last_extension_char`.
    *   **PK:** `(prefix, year_code_val)` 로 설정하여 연도 및 접두사별로 독립적인 카운터 관리.

2.  **데이터베이스 트랜잭션 및 비관적 잠금 (Pessimistic Locking):**
    *   **목적:** 코드 생성 로직(카운터 조회 → 다음 값 계산 → 카운터 업데이트) 전체를 하나의 원자적(Atomic) 단위로 처리하여 데이터 일관성을 보장하고 경쟁 상태(Race Condition)를 방지합니다.
    *   **구현:** 카운터 테이블에서 특정 `(접두사, 년도)` 레코드를 읽을 때 `SELECT ... FOR UPDATE` (또는 해당 DB의 유사 잠금 구문)를 사용하여 해당 레코드에 배타적 잠금을 겁니다.
    *   **효과:** 동시에 여러 요청이 동일한 카운터에 접근하려 할 때, 하나의 트랜잭션만 해당 레코드를 수정할 수 있도록 직렬화되어 순차 처리됩니다.

3.  **최종 코드에 대한 DB 고유 제약 조건 (`UNIQUE Constraint`):**
    *   **목적:** 생성된 최종 코드가 저장될 테이블(예: `TestResults`)의 코드 컬럼(`generated_code`)에 `UNIQUE` 제약 조건을 설정하여, 만약의 경우(로직 오류 등) 중복 코드가 생성되려 할 때 데이터베이스 수준에서 삽입을 차단합니다. 이는 최후의 데이터 정합성 방어선 역할을 합니다.

4.  **애플리케이션 레벨 코드 생성 로직:**
    *   위 "I. 심리 검사 결과 코드 생성 규칙"에 명시된 대로 숫자, 알파벳, 시퀀스, 확장 문자 증가 로직을 애플리케이션 코드 내에 명확하게 구현합니다. 이 로직은 DB에서 가져온 현재 카운터 값을 기반으로 다음 값을 계산합니다.

**기대 효과:**

*   **강력한 중복 방지:** DB 잠금 및 고유 제약 조건으로 동시 요청에도 코드 중복 가능성을 최소화합니다.
*   **데이터 일관성:** 트랜잭션을 통해 코드 생성 과정의 데이터 정합성을 유지합니다.
*   **체계적인 코드 관리:** 규칙에 따라 예측 가능하고 확장 가능한 코드를 생성합니다.
*   **안정성:** DB의 검증된 기능을 활용하여 시스템 안정성을 높입니다.

이 방법을 통해 다수의 동시 사용자가 검사 코드 생성을 요청하더라도 중복 없이, 정의된 규칙에 따라 안전하게 코드를 생성하고 DB에 저장할 수 있습니다.